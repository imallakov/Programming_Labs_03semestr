# подключение модуля pyplot под псевдонимом plt
import matplotlib.pyplot as plt

# подключение библиотеки numpy под псевдонимом np
import numpy as np

# подключение библиотеки sympy под псевдонимом sp
import sympy as sp

# массив координат - 30 точек, равнораспределенных
# в диапазоне от 0 до 10
x = np.linspace(-10.0, 10.0, 500)
# массив значений функции в заданных координатах
y = np.tan(x) + 1.0 / np.tan(x)
# рисование графика функции с помощью функции plot
plt.plot(x, y, label="tan(x)+ctg(x)")
# массив значений функции в заданных координатах
y = 2 * np.cos(3 * x)
# рисование графика функции с помощью функции plot
plt.plot(x, y, label="2cos(3x)")
# включаем параметр чтоб отобразилась наименования функций в рисунке
plt.legend()
# отображение рисунка на экране
plt.show()

# создаём массив А и B
A = np.array([[1, 2], [3, 2]])
B = np.array([[1, -3], [10, 2]])

# находим обратную матрицу от А
A_inv = np.linalg.inv(A)
# умножаем обратную маотрицу от А на В чтоб найти Х
X = np.dot(A_inv, B)
# выводим на экран матрицу Х
print(X)
# проверяем правильно ли мы нашли Х, для этого умножаем матрица А на Х, в ответ мы должны получить матрицу В
proverka = np.dot(A, X)
# выводим на экран результат проверки и смотрим равна ли найденная матрица к матрице В  "должна быть:)"
print(proverka)

# создаём символьные неизвестные
x, y = sp.symbols("x y")
# создаём уравнения из нашего систем уравнений
eq1 = sp.Eq(x**2 - y**2, 1)
eq2 = sp.Eq(x**2 + x * y, 2)
# решаем систему уравнений относительно символьных неизвестных которых мы ранее создали, точнее пайтон решает а мы чилим))
# и сразу выводим на экран то что возвращает функция, а он должен вернуть список(словарь) значений для неизвестных
print(sp.solve([eq1, eq2], [x, y]))
